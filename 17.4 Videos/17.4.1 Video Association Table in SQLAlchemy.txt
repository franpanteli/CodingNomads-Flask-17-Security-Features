-> creating the association table for following users  
   -> in this video, we’ll explore how to set up an association table to allow users to follow one another in a flask application  
   -> the association table will be created between users, where each user has a unique id, and we will establish a relationship between these users to represent following actions  
   -> this association table will be called `follows` and is used to track which users are following others  
   -> you can create an association table in sqlalchemy, which acts as a link between two models  
   -> normally, an association table is created between two tables using a standard sqlalchemy table, but since we want to include additional information (timestamps), we will upgrade this table  

-> designing the follows table with timestamps  
   -> to include the timestamp of when a new follow relationship is created, we will need to modify the association table to handle this extra information  
   -> the follows table will have the following columns:  
     -> `follower_id`: this will be a foreign key referencing the user who is following another user  
     -> `followed_id`: this will be a foreign key referencing the user being followed  
     -> both `follower_id` and `followed_id` columns will be combined to form a composite primary key for the follows table  
     -> `timestamp`: this column will store the timestamp of when the follow relationship was established  
     -> here’s how to set up the table in python using sqlalchemy:  
       ```python  
       class Follow(db.Model):  
           __tablename__ = 'follows'  
           follower_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)  
           followed_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)  
           timestamp = db.Column(db.DateTime, default=datetime.utcnow)  
       ```  
     -> the `timestamp` field will automatically be set when a new follow relationship is added using the default value of the current utc time  

-> establishing relationships in the user model  
   -> in the user model, we need to define two one-to-many relationships to represent the followers and the people a user is following  
   -> these relationships are based on foreign keys that point to the users table  
   -> the first relationship is for users that a specific user is following, so we need to create a back-reference from the `follow` model  
   -> to establish these relationships, use sqlalchemy’s `relationship` function  
     -> we specify the `foreign_keys` attribute to indicate which column serves as the foreign key  
     -> here’s how you can define the relationships:  
       ```python  
       class User(db.Model):  
           __tablename__ = 'user'  
           id = db.Column(db.Integer, primary_key=True)  
           username = db.Column(db.String(120), unique=True, nullable=False)  
           follows = db.relationship(  
               'User', secondary='follows',  
               primaryjoin=(follows.c.follower_id == id),  
               secondaryjoin=(follows.c.followed_id == id),  
               backref=db.backref('followed_by', lazy='joined'),  
               lazy='dynamic', cascade='all, delete-orphan')  
       ```  

-> the backref and cascade options  
   -> we use the `backref` argument in the `relationship` to define a back-reference from the related table (in this case, the `user` model) to the original table  
     -> the `backref` creates a property on the other side of the relationship, enabling us to access the list of followers via the `followed_by` attribute  
     -> the `lazy='joined'` option ensures that the related user objects are loaded in a single query when accessed  
   -> the `cascade` option specifies how changes to the parent object should be propagated to related objects  
     -> by default, the cascade option ensures that when a user is deleted, the associated follow relationships are also deleted, but we want to omit the `delete-orphan` option from the `follows` relationship for the following direction  

-> deleting orphaned rows  
   -> in the `follows` table, when a user is deleted, their associated rows should also be deleted. this is where `delete-orphan` comes in  
     -> the `delete-orphan` option ensures that if a user is removed from the `follows` relationship, their follow rows will also be deleted from the `follows` table  
     -> in our case, the following relationship should not include `delete-orphan` because we want to keep the records even after the user has been removed, ensuring that they persist for the follow relationships to be accurate  

-> helper methods for following and unfollowing users  
   -> after defining the relationships, we can create helper functions to manage following and unfollowing users  
   -> these methods will be defined in the `user` model  
   -> the `follow` method should check if the current user is already following the target user  
     -> if not, a new `follow` object will be created and added to the database  
     -> here’s how the `follow` method can be written in python:  
       ```python  
       def follow(self, user):  
           if not self.is_following(user):  
               follow = Follow(follower_id=self.id, followed_id=user.id)  
               db.session.add(follow)  
               db.session.commit()  
       ```  
   -> the `unfollow` method should check if the current user is following the other user and, if so, remove the corresponding `follow` object from the database:  
     ```python  
     def unfollow(self, user):  
         follow = Follow.query.filter_by(follower_id=self.id, followed_id=user.id).first()  
         if follow:  
             db.session.delete(follow)  
             db.session.commit()  
     ```  
   -> the `is_following` method checks if the current user is following another user  
     -> it verifies if the `follow` object exists in the database and confirms the relationship:  
       ```python  
       def is_following(self, user):  
           return Follow.query.filter_by(follower_id=self.id, followed_id=user.id).count() > 0  
       ```  

-> testing the following functionality  
   -> to test the following functionality, open a flask shell session by running `flask shell`  
   -> create two users in the shell: one for sutton and another for daniel bates  
   -> let sutton follow daniel bates, and then commit the changes to the database  
     -> example in the flask shell:  
       ```python  
       sutton = User(username='Sutton')  
       daniel = User(username='Daniel Bates')  
       db.session.add(sutton)  
       db.session.add(daniel)  
       db.session.commit()  
       sutton.follow(daniel)  
       db.session.commit()  
       ```  
   -> after committing the changes, you can check if sutton is following daniel bates  
     -> you can use the following to see the list of users sutton is following:  
       ```python  
       sutton.follows.all()  # should return a list containing daniel bates  
       ```  

-> examining the follow object  
   -> after following, you can examine the `follow` object to verify the relationship  
     -> the first user will be listed as the `follower`, and the second user as the `followed`  
     -> the timestamp will show when the follow relationship was created  
   -> if you clear the follows table, it should have no rows, confirming that your many-to-many relationship works correctly  

-> conclusion  
   -> in this video, you have learned how to:  
     -> create an association table for tracking follow relationships between users in flask using sqlalchemy  
     -> add relationships between users in the user model with `one-to-many` and `many-to-many` relationships  
     -> include additional data (like timestamps) in the association table  
     -> create helper methods for following, unfollowing, and checking follow status  
     -> test the functionality in a flask shell session to ensure it works as expected  
   -> you’ve now successfully implemented a following system in your flask application, allowing users to follow each other and track these relationships  