-> joining the compositions table with the follows table  
   -> in flask with sqlalchemy, joining tables is a common operation when you need to combine data from multiple tables based on a relationship  
   -> to retrieve compositions submitted by users followed by another user, you need to join the `compositions` table with the `follows` table. the `follows` table tracks who follows whom, and the `compositions` table stores the works of users  
   -> begin by creating a query object with the `composition` model as the argument. this means you’re focusing on retrieving compositions, but you'll be joining with the `follows` table to filter based on which users are followed  

   -> python code to start this process:  
     ```python  
     query = db.session.query(Composition).select_from(Follow).join(Composition)  
     ```  
     in this line:  
     - `db.session.query(Composition)` creates a query object to query the `composition` model  
     - `select_from(Follow)` tells sqlalchemy to start the query from the `follows` table (this will be the left table in the join)  
     - `join(Composition)` creates the join between `follows` and `compositions` tables using the foreign key relationship between the `follows` and `compositions` tables  

-> understanding the join condition  
   -> the join condition specifies how the `follows` table connects to the `compositions` table. in this case, the `follows` table has a `followed_id` column, which is a foreign key to the `user_id` in the `compositions` table  
   -> the join will use the `followed_id` in the `follows` table and match it to the `user_id` in the `compositions` table:  
     ```python  
     query = query.join(Composition, Follow.followed_id == Composition.user_id)  
     ```  
     this line sets the condition for the join, ensuring that you match compositions by users who are being followed. the `Follow.followed_id == Composition.user_id` condition links the `follows` table's `followed_id` column to the `user_id` in the `compositions` table  

-> refining the query to filter by follower  
   -> now, you need to filter the compositions by the user who is doing the following. this is achieved by specifying the `follower_id` column in the `follows` table  
   -> for example, if you want to find compositions of users followed by user 2, you filter on `follower_id = 2`:  
     ```python  
     query = query.filter(Follow.follower_id == 2)  
     ```  
     this line refines the query to only return compositions of users who are followed by user 2, based on the `follower_id` in the `follows` table  

-> testing the query and output  
   -> after refining the query, execute it to get the results. to do this, use `query.all()` to retrieve all compositions that meet the filter condition  
   -> you can then iterate over the results to extract useful information, such as the `artist_id` and `title` of each composition:  
     ```python  
     results = query.all()  
     for composition in results:  
         print(f"Artist ID: {composition.artist_id}, Title: {composition.title}")  
     ```  
     this will print out the `artist_id` and `title` of each composition, confirming that they all belong to users followed by user 2. if you have multiple compositions by different users followed by user 2, each composition will appear in the list  

-> simplifying the query with direct model operations  
   -> you can simplify the query by starting directly with the `composition` object and using the `join` operation within the query. this removes the need to specify `select_from` and streamlines the query logic  
   -> in this case, you can apply the join directly within the `composition` model query:  
     ```python  
     query = db.session.query(Composition).join(Follow, Follow.followed_id == Composition.user_id).filter(Follow.follower_id == 2)  
     results = query.all()  
     ```  
     this query is logically equivalent to the previous one but starts directly from the `composition` model and applies the necessary join and filter conditions in a cleaner manner  

-> reusing the query as a method in the user model  
   -> to reuse this query, encapsulate it in the `user` model as a method. this will allow you to retrieve compositions by users followed by any given user dynamically  
   -> define the `followed_compositions` method in the `user` model, which will return the compositions of users followed by the current user (i.e., the user instance that calls the method):  
     ```python  
     class User(db.Model):  
         id = db.Column(db.Integer, primary_key=True)  
         email = db.Column(db.String(120), unique=True, nullable=False)  
         # other columns  
     
         def followed_compositions(self):  
             return db.session.query(Composition).join(Follow, Follow.followed_id == Composition.user_id).filter(Follow.follower_id == self.id)  
     ```  

   -> in this example, `self.id` refers to the current user’s id. when you call `followed_compositions()` on a user object, it will return all compositions by users that are followed by that specific user  

-> testing the query in a shell session  
   -> to test this method in a shell session, you can first retrieve a user object (for example, user with id 2) and call the `followed_compositions()` method to get all compositions by users followed by this user  
   -> example code for testing:  
     ```python  
     user = User.query.get(2)  
     compositions = user.followed_compositions().all()  
     for composition in compositions:  
         print(f"Artist ID: {composition.artist_id}, Title: {composition.title}")  
     ```  
   -> this will output the compositions by users followed by user 2, confirming that the method works as intended  

-> final thoughts  
   -> this approach demonstrates how to use sqlalchemy and python to join database tables (`compositions` and `follows`), filter data by specific conditions, and reuse queries effectively within a flask application  
   -> by integrating this logic into the `user` model, you can dynamically retrieve compositions from users that a specific user follows, enabling more complex data retrieval and user interactions in your application  