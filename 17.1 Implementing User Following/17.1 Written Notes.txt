-> introduction to the concept of user following in social media apps  
    -> enables users to keep up with others' activities  
    -> introduces many-to-many relationships in databases  

-> database relationships  
    -> relationships link records in a database  
    -> common relationship types: one-to-many, many-to-one, and one-to-one  
    -> one-to-many: foreign key on the "many" side references primary key on the "one" side  
    -> many-to-one: reverse of one-to-many, viewed from the "many" side  
    -> one-to-one: "many" side has only one element  

-> many-to-many relationship  
    -> links many elements on one side to many elements on the other side  
    -> example: a student can take many courses, and a course can have many students  
    -> a single foreign key on both sides doesn't work for this case  

-> association table  
    -> resolves many-to-many relationships into two one-to-many relationships  
    -> middle table (association table) links "students" to "courses"  
    -> example: registration table links students to courses  
    -> queries require two steps: get the courses for a student, then traverse the relationship to get course details  

-> implementing followers in the database  
    -> users following other users uses a self-referential many-to-many relationship  
    -> association table links users to other users, each user can follow many others  

-> optimising the association table  
    -> association tables usually contain just foreign keys, but can track additional data like follow timestamps  
    -> sqlalchemy allows adding extra columns to association tables to track these relationships  
    -> super-association table stores additional info  

-> follow model  
    -> defines the model for tracking follows in the database  
    -> `follow` model has columns for `follower_id`, `following_id`, and `timestamp`  
    -> foreign keys reference the "users" table  
    -> composite primary key formed by both foreign keys  

-> associating the association  
    -> use relationships to link the `follow` model to the `user` model  
    -> define two one-to-many relationships between `user` and `follow`  
    -> use `backref` for reverse access to followers and following  
    -> cascade delete to remove follow records when a user is deleted  

-> python helper methods  
    -> define helper methods in the `user` model for following/unfollowing and checking relationships  
    -> `follow()` method adds a follow record  
    -> `unfollow()` method deletes a follow record  
    -> `is_following()` and `is_a_follower()` methods check relationships  

-> (un)following other users  
    -> view function for following users by checking if the user is already followed  
    -> if the user is valid and not already followed, add them to the follow table  

-> view functions to display users  
    -> create view functions to show followers and who a user is following  
    -> uses pagination to display followers in a user-friendly manner  
    -> example: a function to display followers for a user  

-> add to user template  
    -> add follow/unfollow buttons to the user template  
    -> button visibility depends on whether the user has permission to follow and if the user is not the current user  
    -> display how many followers and following a user has with links to the corresponding view functions  
    -> show "follows you" if the current user is being followed by the displayed user  